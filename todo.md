- [x] scrolling view
- [x] swapping?
- [x] transactional edit: so that exchanging siblings can be undone in one step
      instead of two smaller steps
- [x] multi-cursor
- [x] swap d to ^x, y to ^c
- [x] ^f for find
- [x] f/F for moving forward/backward (so that it's consistent with other
      actions, which is selection mode first, then action)
- [x] moving selection should scroll the page when out of view
- [x] remove windows, as it is useless
- [x] e for eating forward, useful for replacing current node with parent, also might make `d` obsolete
- [x] implement buffer
- [x] use patch for undo (undo history should be stored under buffer) (https://docs.rs/diffy/0.3.0/diffy/)
- [x] implement component
- [x] file picker
- [x] each editor should have a title (filename, prompt etc)
- [x] split window (needed for autocomplete, prompt)
  - parent-child architecture
  - each window can have multiple children window
  - when a window is closed, all of its children are closed
  - each window have a group, if any of the window in the same group is closed
    all windows in the same group should be closed
- [x] autocomplete
- [x] engine: press Enter to open new line below
- [x] fix(editor): backward token buggy
- [x] LSP (after window system implemented)
- [x] engine: d for delete (because I miss delete, eat is weird)
- [x] feat(editor/normal): backspace should not yank
- [x] fix(editor): swap sibling will skip sibling sometimes
- [x] fix(editor): p e ^z e , does not work as expected
- [x] LSP hover
- [x] LSP Diagnostics highlight error range
- [x] LSP Diagnostics show error message
- [x] LSP completion pass in trigger characters, so that typing . or :: provides better completion in Rust
- [x] LSP completion allow edit
- [x] remove e, make px the same as pe
- [x] LSP go to definition
- [x] LSP get references
- [x] screen '[' and ']' not working as expected, now cannot type []
- [x] refactor: SuggestiveEditor and Prompt should use the same underlying component
- [x] screen: show editor error to user
- [x] Format on save
- [x] feat(ui): decorate both sides of a selection with cursor, so that shrinking selection is more obvious
- [x] i = insert at end of selection, I = insert at beginning of selection
- [x] LSP rename
- [x] LSP signature help
- [x] LSP quick action
- [x] ([{ for enclosing current selection with brackets
- [x] crash when formatting
- [x] create a key event macro so that handle_event can be less tedious: e.g. key!(ctrl-a) => do_something()
- [x] perf: rendering is laggy when there's too many diagnostics
- [x] feat(editor/diagnostics-movement): should work for overlapped ranges, A:0-3, B:1-3, C:4-5, starting from A, forward should go to B first before C
- [x] feat(editor): f = go to final selection, F = go to first selection. e.g. sf = final sibling, mf = final match
- [x] feat(editor/delete): allow edit even if there's no next sibling, in this case, collapse the selection
- [x] when cursor at last position, and after formatting the cursor is out of bound, should not crash
- [x] refactor: change all rope.x_to_y to rope.try_x_to_y to avoid crashing
- [x] perf: when LSP is enable, handling key event is very slow
- [x] infinite loop when changing window
- [x] feat(editor): \* to search for the current selection (using AST grep maybe?)
- [x] feat(lsp): go to declaration, type definition of symbol, and implementations
- [x] feat(search): don't use regex, regex is not needed 90% of the time
- [x] feat(editor/word): word should move by camelCase / snake_case, so we can select a word within a variable name
- [x] layout: implement Tall, instead of binary partition
- [x] case transformation group: UPPERCASE, Capital Case, lowercase, camelCase, PascalCase, snake_case, kebab-case (https://docs.rs/convert_case/latest/convert_case/enum.Case.html)
- [x] feat(lsp): search symbols
- [x] feat(editor): global regex search
- [x] soft wrap
- [x] feat(editor): global literal search
- [x] feat(editor): global ast-grep search
- [x] feat(editor): add cursor mode, n = add next, p = add previous
- [x] feat(edtior): add editor cursor mode, ae, where n/p = go to next/previous cursor, d = delete current cursor
- [x] feat(editor): remove shift+i by replacing it with ip, in
- [x] feat(g): 'gfo' for opened editors
- [x] feat(g): 'gfs' for git status files
- [x] feat(f): hide built-in regex like word and character under f, then we can add more like numbers, dates, etc
- [x] incorporate AST grep (https://github.com/ast-grep/ast-grep)
- [] LSP file modifications (add,rename,delete)
- [] g for selecting the next node that is the same generation (descendant
  level from root) as the current node
- [] e for elevate the current node such that it becomes the siblings of its parent
- [] e for enclose the current node with one of the brackets
- [] f for moving to the next node which has the same field name as the current node
- [] mechanism for adding selection to all matching selection within current selection (ctrl+a)
- [] . for selecting the whole file
- [] multi eat parent should not proceed if the final edit overlaps (not too important because we use patch for undo/redo now, so messed up stuff can be undone)
- [] jump should work for multiple selection?
- [] incorporate first-class refactoring (https://github.com/ThePrimeagen/refactoring.nvim)
- [] file tree
- [] feat(editor): tree rotation, e.g. a + (b - c) => b - (a + c)
- [] feat(selection): quickfix list item as a type of selection, undo & add selection works across files
- [] feat(editor): z = align bottom, z again align center, Z = align top, Z again align top
- [] feat: workspaces (similar to tab in Vim)
- [] highlight mode should work like this: if change to line mode, then both end of the selection should select line, same for char, same for word
- [] copy should work between different editors
- [] Enter not working as expected in insert mode
- [] pressing 'b' remove the copied text
- [] Suggestive editor, pressing Enter when there's no filtered item should not get the item
- [] browswer-like for file navigation (use the undo crate https://crates.io/crates/undo)
- [] location list (local to each editor), local diagnostics should use this
- [] dropdown: handle up/down/enter event
- [] apply actions to all quickfix list items
- [] multi-autocomplete with insert
- [] feat(editor/slurp or barf):
  - exchange last nameless sibling (closing bracket), with the next sibling of parent
    - and reverse
  - exchange first nameless sibling (opening bracket), with the previous sibling of parent
    - and reverse
- [] editor(bug): go to previous error always step to the next first before going to the first
- [] editor(lift): move an expression upwards, can be implemented by swapping
  the "section before the current node until its parent" with "current node"
- [] add integration test for every LSP Actions
- [] refactor: handle_event should not mutate the component, but should return dispatch instead, like Elm.
  - This is to standardize the event handling architecture, and also allow keymap to be defined declaractively
- [] feat(lsp/completion): snippet support
- [] treesitter injections, support nested languages like Rust in Markdown
- [] feat(lsp/code-action): command string execution (code action without edit)
- [] feat: small g for going to locations of this file, G for locations to anywhere
- [] feat(editor): match current selection (\*) should open keymap legend
- [] feat(editor): "go" for getting opened files, "gg" for getting git status files
- [] feat(buffer): use tree-sitter incremental parsing to improve performance
- [] feat(editor): go to specific line number
- [] feat(completion): Github Copilot! (contact AlexanderDickie from https://github.com/helix-editor/helix/pull/6865 when Tim is matured enough to accept contributors)
- [] keymap: shift keys are hard to press, bring back hjkl, but hjkl works on object now! For example, press q to go to quickfix-list mode
  press j/k to go to prev/next item, press h/l to go to prev/next quickfix list, question: how does this works for action like delete/swap?
  for motions, h/l = next object, j/k = first object on next/prev line

  for node movement: h = parent, l = kid, j/k = next/prev sibling

- [] each selection mode to have action(s), for example for git hunk, actions are stage-hunk/discard-hunk.
- [] swap jump: press '>', and then jump labels appear, pressing the jump label swaps the current selection with that selection
- [] filter selections/quickfix-list: useful for multi-cursor
- [] fix(buffer/bookmarks): bookmarks not updated upon undo/redo/formatted
- [] feat(g): 'gh' for global git hunks
- [] feat(movement): y = vertical-same-column movement, skip lines without the current column, this might mark d/u unnecessary
- [] feat(editor): remove down/up movement, make u = select_parent, d = diagnostics
- [] feat(editor): scroll mode, press vs to enter scroll mode
- [] feat(key): change ctrl+t to space-t
- [] feat(space-f): for file mode, r = rename, k = kill (delete), a = add, s = save
- [] feat: command mode (for exiting editor, save all file etc)
- [] feat: change k to d, because d is easier to reach in Dvorak, and d (delete) is a more straightforward mnemonics than k (kill)
- [] feat(doc): add motto about having no shift keys for key bindings;
  spammable key like n/p will not hide under layers, but action like "Change
  selection mode to Git Hunk" which is not supposed to be spam should hide
  under layer
- [] feat(keymap): put copy,paste,cut under space, undo/redo a new mode
- [] feat(multicursor): lag because selection set is unnecessarily recomputed for every cursor
